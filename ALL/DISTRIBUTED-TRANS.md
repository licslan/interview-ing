### 分布式事务可能会问的问题
#### 1.分布式事务内容总结？
#### LICSLAN回答: 
     分布式事务
     
     	事务是用来保证一组数据操作的完整性和一致性
        重点是数据的操作的完整性和一致性 重点放到操作上面

        比如：点击订单支付会大概有3部操作
        扣减库存 ：库存简单订单的数量
        下订单：将订单状态修改为已支付
        支付：将钱打给商户商家
        这三步必须都一起成功  其中有一个失败就要回滚
        满足ACID的特性
        事务的四种隔离级别
        事务具有7种传播行为

        分布式+事务？（集群化分布式化处理问题）
        		分布式事务就是将多个节点的事务看成一个整体处理
        		分布式事务由事务参与者，资源服务器，事务管理器等组成
        		常见的分布式事务的例子：支付，下订单等
        				支付（1.修改订单状态已修改2.钱要打给商家钱要付出去3.商家要收到钱 3者缺一不可构成分布式事务）
        				下订单（1.扣库存，2，下一个单子   构成分布式事务）

        分布式事务显示思路？
        		1.2pc 3pc  两阶段事务 三阶段事务
        		2.基于XA的分布式事务 （X/open）  mysql orcle db2  该模型的影子
        		3.基于消息的最终一致性方案  应用也比较广泛  强一致性 会造成 内存和时间的等待
        		4.TCC编程式补偿性事务	这种最为推荐
        			TCC:Try  Confirrm Cancel
        			尝试执行/确认操作/取消操作

        			1.业务应用 启动事务  通知事务协调器
        			2.业务系统调用其他服务暴露的Try接口----》db
        			3.如果服务A 成功 服务B失败 提交事务回滚到事务协调器
        			4.事务协调器调用各个服务的暴露的Cancel接口 回滚所有的事务操作
        			 如果步骤3  各个服务都成功的话调用各个服务暴露的Confirm接口
        基于消息的最终一致性方案和TCC编程式补偿性事务区别和应用场景？
        	1.基于消息事务时强一致性，会存在资源浪费
        		比如对接微信支付支付宝京东支付的话，钱打出去了，就很难弥补回来了用TCC的话  这个时候用基于消息一致性的方案会好一点  会等一切都可以了 才去执行下一步操作
        		资源浪费  线程会等  很多服务会等  可能会产生雪崩之类
        	2.TCC事务是柔性事务，在Try阶段要对资源做预留
        	3.TCC事务在确认或取消阶段释放资源
        	4.与基于消息事务对比，TCC 的时效性更好 （分布式一般不会强调强一致性）


        	事务协调器是什么？
        		是一个分布式事务的一个框架
        		分布式事务框架
        			全局事务服务（GTS  阿里云开发的）  收费
        			蚂蚁蚂蚁金服分布式事务（DTX）      收费
        			国内开源的TCC框架    gitHub
        			开源TCC框架 ByteTCC  github

        			TCC使用
        				1.在需要使用分布式事务的接口上面添加注解
        				2.主事务 子事务 在对应的接口实现上添加@Compensable
        				3.在接口实现上添加confirMethod cancelMethod transactionContextEditor
        				4.实现对应的confirmethod cancelMethod
        				 	注意：confirm方法和cancel方法必须与try方法在同一个类中
        				5.主事务业务都已经实现的差不多了时候才去调用子事务
        					注意：
        						1.在分布式事务里，不要轻易在业务层捕获所有异常
        						2.使用TCC-Transaction时，confirm和cancel的幂等需要自己代码支持

        				一个order主事务  调用了2各子事务  红包 和资金账户

        				为什么要在confirm，cancel里检查订单状态，而不是直接修改为结束状态
        				因为confirm确认的就是刚刚Tty方法里新增的一个订单？
        				为了保证服务的幂等性
        				幂等性：使用形同参数对同一资源重复调用某个接口的结果和调用一次的结果相同    update insert delete   一般使用分布式锁解决

        分布式锁需要解决的问题
        1.互斥性  任意时刻只有一个客户端获取锁
        2.安全性   锁智能由持有该锁的客户端删除 不能被其他客户端删除
        3.死锁     获取锁的客户端因为某些原因而宕机没有释放锁  其他客户端再也无法获取锁而形成死锁的状态
        4.容错	   redis一些节点宕机  任然可以有其他客户端可以获取到锁

        如何使用redis实现分布式锁
        SETNX key value:如果key不存在 则创建并赋值  复杂度O（1）
        如何解决SETNX长期有效的问题
        EXPIRE key seconds
        设置key的生存时间，当key过期时，生存时间为0，会被自动删除
        缺点：原子性得不到满足
        redis2.6212+


        原子操作 包含在一起
        SET key vale [EX seconds [PX millinseconds [NX\XX]
        EX secmonds 设置键的过期时间为second秒
        PX millisecond 设置键的过期时间为milliisecond毫秒
        NX 只在键不存在时 才对键进行设置操作
        XX 只在键已经存在时 才对键进行设置操作
        SET 操作成功完成时  返回OK 否则返回nil


        大量的key同时过期的注意事项
        集中过期 由于清除大量的KEY 很耗时，会会出现短暂的卡顿现象
        	解决方案：在设置key的过期时间的时候，给每个key加上随机值


        redis 如何做持久化
        1.RDB 快照持久化 保存某个时间点的全量数据快照
        	SAVE :阻塞redis的服务器进程，直到RDB 文件被创建完毕
        	BGSAVE:Fork出一个子进程来创建RDB 文件，不阻塞服务器进程

        缺点：
        	内存数据的全量同步，数据量	大会由于IO而严重影响性能
